-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\BiSS_Splitter_Rev7\Chart.vhd
-- Created: 2020-08-28 16:31:32
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Chart
-- Source Path: BiSS_Splitter_Rev7/Buffer/Chart
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.BiSS_Splitter_Rev7_pac.ALL;

ENTITY Chart IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        detected_error                    :   IN    std_logic;
        clock                             :   IN    std_logic;
        bit_in                            :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        motor_rClock                      :   IN    std_logic;
        motor_rRequest                    :   IN    std_logic;
        DAQ_rClock                        :   IN    std_logic;
        DAQ_rRequest                      :   IN    std_logic;
        write_Request                     :   IN    std_logic;
        write_ad                          :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        write_en                          :   OUT   std_logic;
        read_ad                           :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        DAQ_outEn                         :   OUT   std_logic;
        motor_outEn                       :   OUT   std_logic;
        DAQ_done                          :   OUT   std_logic;
        motor_done                        :   OUT   std_logic
        );
END Chart;


ARCHITECTURE rtl OF Chart IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL bit_in_unsigned                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL is_Chart                         : T_state_type_is_Chart;  -- uint8
  SIGNAL write_ad_tmp                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL read_ad_tmp                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL bankToggle2                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL bankToggle1                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL onDigit_read                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL read_keeper                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL write_keeper                     : std_logic;
  SIGNAL write_ad_reg                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL write_en_reg                     : std_logic;
  SIGNAL read_ad_reg                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL DAQ_outEn_reg                    : std_logic;
  SIGNAL motor_outEn_reg                  : std_logic;
  SIGNAL DAQ_done_reg                     : std_logic;
  SIGNAL motor_done_reg                   : std_logic;
  SIGNAL is_Chart_next                    : T_state_type_is_Chart;  -- enum type state_type_is_Chart (8 enums)
  SIGNAL bankToggle2_next                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL bankToggle1_next                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL onDigit_read_next                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL read_keeper_next                 : signed(7 DOWNTO 0);  -- int8
  SIGNAL write_keeper_next                : std_logic;
  SIGNAL write_ad_reg_next                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL write_en_reg_next                : std_logic;
  SIGNAL read_ad_reg_next                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL DAQ_outEn_reg_next               : std_logic;
  SIGNAL motor_outEn_reg_next             : std_logic;
  SIGNAL DAQ_done_reg_next                : std_logic;
  SIGNAL motor_done_reg_next              : std_logic;

BEGIN
  bit_in_unsigned <= unsigned(bit_in);

  Chart_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        onDigit_read <= to_unsigned(16#00#, 8);
        read_keeper <= to_signed(16#00#, 8);
        write_keeper <= '0';
        write_ad_reg <= to_unsigned(16#00#, 8);
        write_en_reg <= '0';
        read_ad_reg <= to_unsigned(16#00#, 8);
        DAQ_outEn_reg <= '0';
        motor_outEn_reg <= '0';
        DAQ_done_reg <= '0';
        motor_done_reg <= '0';
        is_Chart <= IN_Initialization;
        bankToggle1 <= to_unsigned(16#00#, 8);
        bankToggle2 <= to_unsigned(16#01#, 8);
      ELSIF enb = '1' THEN
        is_Chart <= is_Chart_next;
        bankToggle2 <= bankToggle2_next;
        bankToggle1 <= bankToggle1_next;
        onDigit_read <= onDigit_read_next;
        read_keeper <= read_keeper_next;
        write_keeper <= write_keeper_next;
        write_ad_reg <= write_ad_reg_next;
        write_en_reg <= write_en_reg_next;
        read_ad_reg <= read_ad_reg_next;
        DAQ_outEn_reg <= DAQ_outEn_reg_next;
        motor_outEn_reg <= motor_outEn_reg_next;
        DAQ_done_reg <= DAQ_done_reg_next;
        motor_done_reg <= motor_done_reg_next;
      END IF;
    END IF;
  END PROCESS Chart_1_process;

  Chart_1_output : PROCESS (DAQ_done_reg, DAQ_outEn_reg, DAQ_rClock, DAQ_rRequest, bankToggle1,
       bankToggle2, bit_in_unsigned, clock, detected_error, is_Chart,
       motor_done_reg, motor_outEn_reg, motor_rClock, motor_rRequest,
       onDigit_read, read_ad_reg, read_keeper, write_Request, write_ad_reg,
       write_en_reg, write_keeper)
    VARIABLE sf_internal_predicateOutput : std_logic;
    VARIABLE sf_internal_predicateoutput_0 : std_logic;
    VARIABLE sf_internal_predicateoutput_1 : std_logic;
    VARIABLE sf_internal_predicateoutput_2 : std_logic;
    VARIABLE b_sf_internal_predicateOutput : std_logic;
    VARIABLE c_sf_internal_predicateOutput : std_logic;
    VARIABLE d_sf_internal_predicateOutput : std_logic;
    VARIABLE e_sf_internal_predicateOutput : std_logic;
    VARIABLE onDigit_read_temp : unsigned(7 DOWNTO 0);
    VARIABLE write_keeper_temp : std_logic;
    VARIABLE mul_temp : unsigned(13 DOWNTO 0);
    VARIABLE add_cast : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_0 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_1 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_2 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_3 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_0 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_1 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_2 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_4 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_1 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_3 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_4 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_5 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_2 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_5 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_6 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_6 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_3 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_7 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_8 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_7 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_4 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_9 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_10 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_8 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_5 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_11 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_12 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_9 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_6 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_13 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_14 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_10 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_7 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_15 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_16 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_11 : unsigned(8 DOWNTO 0);
    VARIABLE mul_temp_8 : unsigned(13 DOWNTO 0);
    VARIABLE add_cast_17 : unsigned(7 DOWNTO 0);
    VARIABLE add_cast_18 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_12 : unsigned(8 DOWNTO 0);
  BEGIN
    sf_internal_predicateOutput := '0';
    sf_internal_predicateoutput_0 := '0';
    sf_internal_predicateoutput_1 := '0';
    sf_internal_predicateoutput_2 := '0';
    b_sf_internal_predicateOutput := '0';
    c_sf_internal_predicateOutput := '0';
    d_sf_internal_predicateOutput := '0';
    e_sf_internal_predicateOutput := '0';
    mul_temp := to_unsigned(16#0000#, 14);
    add_temp := to_unsigned(16#000#, 9);
    add_temp_0 := to_unsigned(16#000#, 9);
    add_temp_1 := to_unsigned(16#000#, 9);
    add_temp_2 := to_unsigned(16#000#, 9);
    add_temp_3 := to_unsigned(16#000#, 9);
    mul_temp_0 := to_unsigned(16#0000#, 14);
    add_temp_4 := to_unsigned(16#000#, 9);
    mul_temp_1 := to_unsigned(16#0000#, 14);
    add_temp_5 := to_unsigned(16#000#, 9);
    mul_temp_2 := to_unsigned(16#0000#, 14);
    add_temp_6 := to_unsigned(16#000#, 9);
    mul_temp_3 := to_unsigned(16#0000#, 14);
    add_temp_7 := to_unsigned(16#000#, 9);
    mul_temp_4 := to_unsigned(16#0000#, 14);
    add_temp_8 := to_unsigned(16#000#, 9);
    mul_temp_5 := to_unsigned(16#0000#, 14);
    add_temp_9 := to_unsigned(16#000#, 9);
    mul_temp_6 := to_unsigned(16#0000#, 14);
    add_temp_10 := to_unsigned(16#000#, 9);
    mul_temp_7 := to_unsigned(16#0000#, 14);
    add_temp_11 := to_unsigned(16#000#, 9);
    mul_temp_8 := to_unsigned(16#0000#, 14);
    add_temp_12 := to_unsigned(16#000#, 9);
    add_cast := to_unsigned(16#00#, 8);
    add_cast_0 := to_unsigned(16#000#, 9);
    add_cast_1 := to_unsigned(16#00#, 8);
    add_cast_2 := to_unsigned(16#000#, 9);
    add_cast_3 := to_unsigned(16#00#, 8);
    add_cast_4 := to_unsigned(16#000#, 9);
    add_cast_5 := to_unsigned(16#00#, 8);
    add_cast_6 := to_unsigned(16#000#, 9);
    add_cast_7 := to_unsigned(16#00#, 8);
    add_cast_8 := to_unsigned(16#000#, 9);
    add_cast_9 := to_unsigned(16#00#, 8);
    add_cast_10 := to_unsigned(16#000#, 9);
    add_cast_11 := to_unsigned(16#00#, 8);
    add_cast_12 := to_unsigned(16#000#, 9);
    add_cast_13 := to_unsigned(16#00#, 8);
    add_cast_14 := to_unsigned(16#000#, 9);
    add_cast_15 := to_unsigned(16#00#, 8);
    add_cast_16 := to_unsigned(16#000#, 9);
    add_cast_17 := to_unsigned(16#00#, 8);
    add_cast_18 := to_unsigned(16#000#, 9);
    onDigit_read_temp := onDigit_read;
    write_keeper_temp := write_keeper;
    write_ad_reg_next <= write_ad_reg;
    write_en_reg_next <= write_en_reg;
    read_ad_reg_next <= read_ad_reg;
    DAQ_outEn_reg_next <= DAQ_outEn_reg;
    motor_outEn_reg_next <= motor_outEn_reg;
    DAQ_done_reg_next <= DAQ_done_reg;
    motor_done_reg_next <= motor_done_reg;
    is_Chart_next <= is_Chart;
    bankToggle2_next <= bankToggle2;
    bankToggle1_next <= bankToggle1;
    read_keeper_next <= read_keeper;
    CASE is_Chart IS
      WHEN IN_DAQRead =>
        IF onDigit_read = to_unsigned(16#2A#, 8) THEN 
          DAQ_done_reg_next <= '1';
          DAQ_outEn_reg_next <= '0';
          read_ad_reg_next <= to_unsigned(16#00#, 8);
          is_Chart_next <= IN_NormalOperation;
        ELSE 
          IF ((DAQ_rClock AND hdlcoder_to_stdlogic(read_keeper = to_signed(16#00#, 8))) AND hdlcoder_to_stdlogic(onDigit_read < to_unsigned(16#2A#, 8))) = '1' THEN 
            add_temp_0 := resize(onDigit_read, 9) + to_unsigned(16#001#, 9);
            IF add_temp_0(8) /= '0' THEN 
              onDigit_read_temp := "11111111";
            ELSE 
              onDigit_read_temp := add_temp_0(7 DOWNTO 0);
            END IF;
            read_keeper_next <= to_signed(16#01#, 8);
          ELSIF ( NOT DAQ_rClock) = '1' THEN 
            read_keeper_next <= to_signed(16#00#, 8);
          END IF;
          mul_temp_0 := bankToggle2 * to_unsigned(16#32#, 6);
          IF mul_temp_0(13 DOWNTO 8) /= "000000" THEN 
            add_cast_1 := "11111111";
          ELSE 
            add_cast_1 := mul_temp_0(7 DOWNTO 0);
          END IF;
          add_cast_2 := resize(add_cast_1, 9);
          add_temp_4 := resize(onDigit_read_temp, 9) + add_cast_2;
          IF add_temp_4(8) /= '0' THEN 
            read_ad_reg_next <= "11111111";
          ELSE 
            read_ad_reg_next <= add_temp_4(7 DOWNTO 0);
          END IF;
        END IF;
      WHEN IN_DAQReadandWrite =>
        sf_internal_predicateOutput := hdlcoder_to_stdlogic((bit_in_unsigned = to_unsigned(16#00#, 8)) AND (onDigit_read = to_unsigned(16#2A#, 8)));
        IF sf_internal_predicateOutput = '1' THEN 
          motor_done_reg_next <= '1';
          motor_outEn_reg_next <= '0';
          write_en_reg_next <= '0';
          write_ad_reg_next <= to_unsigned(16#00#, 8);
          read_ad_reg_next <= to_unsigned(16#00#, 8);
          is_Chart_next <= IN_SwitchBank;
        ELSE 
          IF ((DAQ_rClock AND hdlcoder_to_stdlogic(read_keeper = to_signed(16#00#, 8))) AND hdlcoder_to_stdlogic(onDigit_read < to_unsigned(16#2A#, 8))) = '1' THEN 
            add_temp_1 := resize(onDigit_read, 9) + to_unsigned(16#001#, 9);
            IF add_temp_1(8) /= '0' THEN 
              onDigit_read_temp := "11111111";
            ELSE 
              onDigit_read_temp := add_temp_1(7 DOWNTO 0);
            END IF;
            read_keeper_next <= to_signed(16#01#, 8);
          ELSIF ( NOT DAQ_rClock) = '1' THEN 
            read_keeper_next <= to_signed(16#00#, 8);
          END IF;
          mul_temp_1 := bankToggle2 * to_unsigned(16#32#, 6);
          IF mul_temp_1(13 DOWNTO 8) /= "000000" THEN 
            add_cast_3 := "11111111";
          ELSE 
            add_cast_3 := mul_temp_1(7 DOWNTO 0);
          END IF;
          add_cast_4 := resize(add_cast_3, 9);
          add_temp_5 := resize(onDigit_read_temp, 9) + add_cast_4;
          IF add_temp_5(8) /= '0' THEN 
            read_ad_reg_next <= "11111111";
          ELSE 
            read_ad_reg_next <= add_temp_5(7 DOWNTO 0);
          END IF;
          IF bit_in_unsigned = to_unsigned(16#00#, 8) THEN 
            write_keeper_temp := '1';
            write_ad_reg_next <= to_unsigned(16#00#, 8);
          END IF;
          IF ( NOT write_keeper_temp) = '1' THEN 
            mul_temp_5 := bankToggle1 * to_unsigned(16#32#, 6);
            IF mul_temp_5(13 DOWNTO 8) /= "000000" THEN 
              add_cast_11 := "11111111";
            ELSE 
              add_cast_11 := mul_temp_5(7 DOWNTO 0);
            END IF;
            add_cast_12 := resize(add_cast_11, 9);
            add_temp_9 := resize(bit_in_unsigned, 9) + add_cast_12;
            IF add_temp_9(8) /= '0' THEN 
              write_ad_reg_next <= "11111111";
            ELSE 
              write_ad_reg_next <= add_temp_9(7 DOWNTO 0);
            END IF;
          END IF;
          write_en_reg_next <= hdlcoder_to_stdlogic((clock AND ( NOT write_keeper_temp)) = '1');
        END IF;
      WHEN IN_Initialization =>
        is_Chart_next <= IN_NormalOperation;
      WHEN IN_MotorRead =>
        sf_internal_predicateoutput_0 := hdlcoder_to_stdlogic((hdlcoder_to_stdlogic(onDigit_read = to_unsigned(16#2A#, 8)) AND ( NOT motor_rClock)) = '1');
        IF sf_internal_predicateoutput_0 = '1' THEN 
          motor_done_reg_next <= '1';
          motor_outEn_reg_next <= '0';
          read_ad_reg_next <= to_unsigned(16#00#, 8);
          is_Chart_next <= IN_NormalOperation;
        ELSE 
          IF ((motor_rClock AND hdlcoder_to_stdlogic(read_keeper = to_signed(16#00#, 8))) AND hdlcoder_to_stdlogic(onDigit_read < to_unsigned(16#2A#, 8))) = '1' THEN 
            add_temp_2 := resize(onDigit_read, 9) + to_unsigned(16#001#, 9);
            IF add_temp_2(8) /= '0' THEN 
              onDigit_read_temp := "11111111";
            ELSE 
              onDigit_read_temp := add_temp_2(7 DOWNTO 0);
            END IF;
            read_keeper_next <= to_signed(16#01#, 8);
          ELSIF ( NOT motor_rClock) = '1' THEN 
            read_keeper_next <= to_signed(16#00#, 8);
          END IF;
          mul_temp_2 := bankToggle2 * to_unsigned(16#32#, 6);
          IF mul_temp_2(13 DOWNTO 8) /= "000000" THEN 
            add_cast_5 := "11111111";
          ELSE 
            add_cast_5 := mul_temp_2(7 DOWNTO 0);
          END IF;
          add_cast_6 := resize(add_cast_5, 9);
          add_temp_6 := resize(onDigit_read_temp, 9) + add_cast_6;
          IF add_temp_6(8) /= '0' THEN 
            read_ad_reg_next <= "11111111";
          ELSE 
            read_ad_reg_next <= add_temp_6(7 DOWNTO 0);
          END IF;
        END IF;
      WHEN IN_MotorReadandWrite =>
        sf_internal_predicateoutput_1 := hdlcoder_to_stdlogic((bit_in_unsigned = to_unsigned(16#00#, 8)) AND (onDigit_read = to_unsigned(16#2A#, 8)));
        IF sf_internal_predicateoutput_1 = '1' THEN 
          motor_done_reg_next <= '1';
          motor_outEn_reg_next <= '0';
          write_en_reg_next <= '0';
          write_ad_reg_next <= to_unsigned(16#00#, 8);
          read_ad_reg_next <= to_unsigned(16#00#, 8);
          is_Chart_next <= IN_SwitchBank;
        ELSE 
          IF ((motor_rClock AND hdlcoder_to_stdlogic(read_keeper = to_signed(16#00#, 8))) AND hdlcoder_to_stdlogic(onDigit_read < to_unsigned(16#2A#, 8))) = '1' THEN 
            add_temp_3 := resize(onDigit_read, 9) + to_unsigned(16#001#, 9);
            IF add_temp_3(8) /= '0' THEN 
              onDigit_read_temp := "11111111";
            ELSE 
              onDigit_read_temp := add_temp_3(7 DOWNTO 0);
            END IF;
            read_keeper_next <= to_signed(16#01#, 8);
          ELSIF ( NOT motor_rClock) = '1' THEN 
            read_keeper_next <= to_signed(16#00#, 8);
          END IF;
          mul_temp_3 := bankToggle2 * to_unsigned(16#32#, 6);
          IF mul_temp_3(13 DOWNTO 8) /= "000000" THEN 
            add_cast_7 := "11111111";
          ELSE 
            add_cast_7 := mul_temp_3(7 DOWNTO 0);
          END IF;
          add_cast_8 := resize(add_cast_7, 9);
          add_temp_7 := resize(onDigit_read_temp, 9) + add_cast_8;
          IF add_temp_7(8) /= '0' THEN 
            read_ad_reg_next <= "11111111";
          ELSE 
            read_ad_reg_next <= add_temp_7(7 DOWNTO 0);
          END IF;
          IF bit_in_unsigned = to_unsigned(16#00#, 8) THEN 
            write_keeper_temp := '1';
            write_ad_reg_next <= to_unsigned(16#00#, 8);
          END IF;
          IF ( NOT write_keeper_temp) = '1' THEN 
            mul_temp_6 := bankToggle1 * to_unsigned(16#32#, 6);
            IF mul_temp_6(13 DOWNTO 8) /= "000000" THEN 
              add_cast_13 := "11111111";
            ELSE 
              add_cast_13 := mul_temp_6(7 DOWNTO 0);
            END IF;
            add_cast_14 := resize(add_cast_13, 9);
            add_temp_10 := resize(bit_in_unsigned, 9) + add_cast_14;
            IF add_temp_10(8) /= '0' THEN 
              write_ad_reg_next <= "11111111";
            ELSE 
              write_ad_reg_next <= add_temp_10(7 DOWNTO 0);
            END IF;
          END IF;
          write_en_reg_next <= hdlcoder_to_stdlogic((clock AND ( NOT write_keeper_temp)) = '1');
        END IF;
      WHEN IN_NormalOperation =>
        sf_internal_predicateoutput_2 := hdlcoder_to_stdlogic(((motor_rRequest AND write_Request) AND hdlcoder_to_stdlogic(bit_in_unsigned = to_unsigned(16#01#, 8))) = '1');
        IF sf_internal_predicateoutput_2 = '1' THEN 
          motor_done_reg_next <= '0';
          DAQ_done_reg_next <= '0';
          is_Chart_next <= IN_MotorReadandWrite;
          read_keeper_next <= to_signed(16#00#, 8);
          onDigit_read_temp := to_unsigned(16#00#, 8);
          write_keeper_temp := '0';
          mul_temp_4 := bankToggle1 * to_unsigned(16#32#, 6);
          IF mul_temp_4(13 DOWNTO 8) /= "000000" THEN 
            add_cast_9 := "11111111";
          ELSE 
            add_cast_9 := mul_temp_4(7 DOWNTO 0);
          END IF;
          add_cast_10 := resize(add_cast_9, 9);
          add_temp_8 := resize(bit_in_unsigned, 9) + add_cast_10;
          IF add_temp_8(8) /= '0' THEN 
            write_ad_reg_next <= "11111111";
          ELSE 
            write_ad_reg_next <= add_temp_8(7 DOWNTO 0);
          END IF;
          motor_outEn_reg_next <= '1';
          write_en_reg_next <= hdlcoder_to_stdlogic(clock = '1');
        ELSE 
          b_sf_internal_predicateOutput := hdlcoder_to_stdlogic((motor_rRequest AND ( NOT write_Request)) = '1');
          IF b_sf_internal_predicateOutput = '1' THEN 
            motor_done_reg_next <= '0';
            DAQ_done_reg_next <= '0';
            is_Chart_next <= IN_MotorRead;
            read_keeper_next <= to_signed(16#00#, 8);
            onDigit_read_temp := to_unsigned(16#00#, 8);
            motor_outEn_reg_next <= '1';
          ELSE 
            c_sf_internal_predicateOutput := hdlcoder_to_stdlogic(((DAQ_rRequest AND write_Request) AND hdlcoder_to_stdlogic(bit_in_unsigned = to_unsigned(16#01#, 8))) = '1');
            IF c_sf_internal_predicateOutput = '1' THEN 
              motor_done_reg_next <= '0';
              DAQ_done_reg_next <= '0';
              is_Chart_next <= IN_DAQReadandWrite;
              read_keeper_next <= to_signed(16#00#, 8);
              onDigit_read_temp := to_unsigned(16#00#, 8);
              write_keeper_temp := '0';
              mul_temp_7 := bankToggle1 * to_unsigned(16#32#, 6);
              IF mul_temp_7(13 DOWNTO 8) /= "000000" THEN 
                add_cast_15 := "11111111";
              ELSE 
                add_cast_15 := mul_temp_7(7 DOWNTO 0);
              END IF;
              add_cast_16 := resize(add_cast_15, 9);
              add_temp_11 := resize(bit_in_unsigned, 9) + add_cast_16;
              IF add_temp_11(8) /= '0' THEN 
                write_ad_reg_next <= "11111111";
              ELSE 
                write_ad_reg_next <= add_temp_11(7 DOWNTO 0);
              END IF;
              motor_outEn_reg_next <= '1';
              write_en_reg_next <= hdlcoder_to_stdlogic(clock = '1');
            ELSE 
              d_sf_internal_predicateOutput := hdlcoder_to_stdlogic((DAQ_rRequest AND ( NOT write_Request)) = '1');
              IF d_sf_internal_predicateOutput = '1' THEN 
                motor_done_reg_next <= '0';
                DAQ_done_reg_next <= '0';
                is_Chart_next <= IN_DAQRead;
                read_keeper_next <= to_signed(16#00#, 8);
                onDigit_read_temp := to_unsigned(16#00#, 8);
                DAQ_outEn_reg_next <= '1';
              ELSE 
                e_sf_internal_predicateOutput := hdlcoder_to_stdlogic((write_Request AND hdlcoder_to_stdlogic(bit_in_unsigned = to_unsigned(16#01#, 8))) = '1');
                IF e_sf_internal_predicateOutput = '1' THEN 
                  motor_done_reg_next <= '0';
                  DAQ_done_reg_next <= '0';
                  is_Chart_next <= IN_WriteOnly;
                  mul_temp_8 := bankToggle1 * to_unsigned(16#32#, 6);
                  IF mul_temp_8(13 DOWNTO 8) /= "000000" THEN 
                    add_cast_17 := "11111111";
                  ELSE 
                    add_cast_17 := mul_temp_8(7 DOWNTO 0);
                  END IF;
                  add_cast_18 := resize(add_cast_17, 9);
                  add_temp_12 := resize(bit_in_unsigned, 9) + add_cast_18;
                  IF add_temp_12(8) /= '0' THEN 
                    write_ad_reg_next <= "11111111";
                  ELSE 
                    write_ad_reg_next <= add_temp_12(7 DOWNTO 0);
                  END IF;
                  write_en_reg_next <= hdlcoder_to_stdlogic(clock = '1');
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      WHEN IN_SwitchBank =>
        IF ( NOT detected_error) = '1' THEN 
          IF bankToggle1 = to_unsigned(16#00#, 8) THEN 
            bankToggle1_next <= to_unsigned(16#01#, 8);
            bankToggle2_next <= to_unsigned(16#00#, 8);
          ELSE 
            bankToggle1_next <= to_unsigned(16#00#, 8);
            bankToggle2_next <= to_unsigned(16#01#, 8);
          END IF;
        END IF;
        is_Chart_next <= IN_NormalOperation;
      WHEN OTHERS => 
        --case IN_WriteOnly:
        IF bit_in_unsigned = to_unsigned(16#00#, 8) THEN 
          write_en_reg_next <= '0';
          write_ad_reg_next <= to_unsigned(16#00#, 8);
          is_Chart_next <= IN_SwitchBank;
        ELSE 
          mul_temp := bankToggle1 * to_unsigned(16#32#, 6);
          IF mul_temp(13 DOWNTO 8) /= "000000" THEN 
            add_cast := "11111111";
          ELSE 
            add_cast := mul_temp(7 DOWNTO 0);
          END IF;
          add_cast_0 := resize(add_cast, 9);
          add_temp := resize(bit_in_unsigned, 9) + add_cast_0;
          IF add_temp(8) /= '0' THEN 
            write_ad_reg_next <= "11111111";
          ELSE 
            write_ad_reg_next <= add_temp(7 DOWNTO 0);
          END IF;
          write_en_reg_next <= hdlcoder_to_stdlogic(clock = '1');
        END IF;
    END CASE;
    onDigit_read_next <= onDigit_read_temp;
    write_keeper_next <= write_keeper_temp;
  END PROCESS Chart_1_output;

  write_ad_tmp <= write_ad_reg_next;
  write_en <= write_en_reg_next;
  read_ad_tmp <= read_ad_reg_next;
  DAQ_outEn <= DAQ_outEn_reg_next;
  motor_outEn <= motor_outEn_reg_next;
  DAQ_done <= DAQ_done_reg_next;
  motor_done <= motor_done_reg_next;

  write_ad <= std_logic_vector(write_ad_tmp);

  read_ad <= std_logic_vector(read_ad_tmp);

END rtl;

